<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>实验二 | My blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="This is a blog.">
    
    <link rel="preload" href="/assets/css/0.styles.e4d8b86b.css" as="style"><link rel="preload" href="/assets/js/app.0c046186.js" as="script"><link rel="preload" href="/assets/js/2.81c555ed.js" as="script"><link rel="preload" href="/assets/js/16.78ed62cb.js" as="script"><link rel="prefetch" href="/assets/js/10.f6541d8c.js"><link rel="prefetch" href="/assets/js/11.f1dce746.js"><link rel="prefetch" href="/assets/js/12.01c79aa3.js"><link rel="prefetch" href="/assets/js/13.25229fd7.js"><link rel="prefetch" href="/assets/js/14.4d02f666.js"><link rel="prefetch" href="/assets/js/15.841d587c.js"><link rel="prefetch" href="/assets/js/17.378d7cbc.js"><link rel="prefetch" href="/assets/js/18.dcd0dd81.js"><link rel="prefetch" href="/assets/js/19.e4f29718.js"><link rel="prefetch" href="/assets/js/20.53d3b577.js"><link rel="prefetch" href="/assets/js/21.ebd90feb.js"><link rel="prefetch" href="/assets/js/22.698bbbfa.js"><link rel="prefetch" href="/assets/js/23.dc38355d.js"><link rel="prefetch" href="/assets/js/24.5a977ef4.js"><link rel="prefetch" href="/assets/js/25.a196ba64.js"><link rel="prefetch" href="/assets/js/26.f65db146.js"><link rel="prefetch" href="/assets/js/27.cdd690da.js"><link rel="prefetch" href="/assets/js/28.ce9a1d95.js"><link rel="prefetch" href="/assets/js/29.eb1637b1.js"><link rel="prefetch" href="/assets/js/3.33041445.js"><link rel="prefetch" href="/assets/js/30.dba066d7.js"><link rel="prefetch" href="/assets/js/4.e7c996f5.js"><link rel="prefetch" href="/assets/js/5.6eff8140.js"><link rel="prefetch" href="/assets/js/6.17d5dd20.js"><link rel="prefetch" href="/assets/js/7.c59592f3.js"><link rel="prefetch" href="/assets/js/8.88076c9a.js"><link rel="prefetch" href="/assets/js/9.b71dc2a4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e4d8b86b.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="./assets/img/logo.png" alt="My blog" class="logo"> <span class="site-name can-hide">My blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link router-link-active">
  主页
</a></div><div class="nav-item"><a href="https://blog.csdn.net/weixin_45651943" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link router-link-active">
  主页
</a></div><div class="nav-item"><a href="https://blog.csdn.net/weixin_45651943" target="_blank" rel="noopener noreferrer" class="nav-link external">
  CSDN博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="/guide.html" class="nav-link">
  关于我
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/sidebar_lesson" class="sidebar-heading clickable"><span>软件构造课程</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/sidebar_experiment" class="sidebar-heading clickable open"><span>软件构造实验</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/experiment.html" class="sidebar-link">软件构造实验指导</a></li><li><a href="/sidebar_experiment1.html" class="sidebar-link">实验一</a></li><li><a href="/sidebar_experiment2.html" aria-current="page" class="active sidebar-link">实验二</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#实验目标概述" class="sidebar-link">实验目标概述</a></li><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#实验环境配置" class="sidebar-link">实验环境配置</a></li><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#实验过程" class="sidebar-link">实验过程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#poetic-walks" class="sidebar-link">Poetic Walks</a></li><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#re-implement-the-social-network-in-lab1" class="sidebar-link">Re-implement the Social Network in Lab1</a></li></ul></li><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#实验过程中遇到的困难与解决途径" class="sidebar-link">实验过程中遇到的困难与解决途径</a></li><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#实验过程中收获的经验、教训、感想" class="sidebar-link">实验过程中收获的经验、教训、感想</a></li><li class="sidebar-sub-header"><a href="/sidebar_experiment2.html#针对以下方面的感受" class="sidebar-link">针对以下方面的感受</a></li></ul></li><li><a href="/sidebar_experiment3.html" class="sidebar-link">实验三</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/sidebar_CSAPP" class="sidebar-heading clickable"><span>计算机系统</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="实验二"><a href="#实验二" class="header-anchor">#</a> 实验二</h1> <h2 id="实验目标概述"><a href="#实验目标概述" class="header-anchor">#</a> 实验目标概述</h2> <p>本次实验训练抽象数据类型（ADT）的设计、规约、测试，并使用面向对象编程（OOP）技术实现ADT。具体来说：</p> <ul><li>针对给定的应用问题，从问题描述中识别所需的ADT；</li> <li>设计ADT规约（pre-condition、post-condition）并评估规约的质量；</li> <li>根据ADT的规约设计测试用例；</li> <li>ADT的泛型化；</li> <li>根据规约设计ADT的多种不同的实现；针对每种实现，设计其表示（representation）、表示不变性（rep invariant）、抽象过程（abstraction function）</li> <li>使用OOP实现ADT，并判定表示不变性是否违反、各实现是否存在表示泄露（rep exposure）；</li> <li>测试ADT的实现并评估测试的覆盖度；</li> <li>使用ADT及其实现，为应用问题开发程序；</li> <li>在测试代码中，能够写出testing strategy并据此设计测试用例。</li></ul> <h2 id="实验环境配置"><a href="#实验环境配置" class="header-anchor">#</a> 实验环境配置</h2> <p>环境配置：
IntelliJ IDEA 2020.3.1  (JDK 1.8  Junit 4.12(下载到lib目录中))</p> <p><img src="/SoftwareConstruction/experiment2/image002.png" alt="image002.png"></p> <p>GitHub Lab2 URL:
<a href="https://github.com/ComputerScienceHIT/HIT-Lab2-1190200708" target="_blank" rel="noopener noreferrer">github url<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="实验过程"><a href="#实验过程" class="header-anchor">#</a> 实验过程</h2> <h3 id="poetic-walks"><a href="#poetic-walks" class="header-anchor">#</a> Poetic Walks</h3> <h4 id="get-the-code-and-prepare-git-repository"><a href="#get-the-code-and-prepare-git-repository" class="header-anchor">#</a> Get the code and prepare Git repository</h4> <p>使用git clone命令从远程仓库中获取源代码</p> <p>git clone https://github.com/rainywang/Spring2020_HITCS_SC_Lab2/tree/master/P1</p> <p>并在本地使用git init命令建立git仓库。</p> <p>通过git add . 命令添加所有文件，在通过git commit -m “message”的命令，提交本地项目，通过git remote add origin &lt;url&gt;的命令关联远程仓库，并使用git push -u origin master的命令，将其推送到远程github仓库。</p> <p>我们也可以通过git log命令，详细查看提交记录，可以查看到不同版本。</p> <p><strong>总结：我们可以通过git status查看状态，git add . 添加文件，git commit -m “描述信息”生成版本控制，git log查看不同版本。</strong></p> <h4 id="problem-1-test-graph-string"><a href="#problem-1-test-graph-string" class="header-anchor">#</a> Problem 1: Test Graph &lt;String&gt;</h4> <ul><li>1&gt;	public boolean add(L vertex);</li></ul> <p>设计：我们此时根据图是否为空，待添加顶点是否在图中作为输入的区分，因此我们应该对这几种情况的笛卡尔积做测试。将此时分为三种情况：</p> <p>图为空，则vertex不在图中</p> <p>图不为空，且vertex不在图中</p> <p>图不为空，且vertex在图中</p> <p>思路、过程：根据方法上方的注释分析，此时我们需要添加一个顶点到这个图，若该图中没有包含该顶点，则返回true，否则我们应该返回false。因此，对于这种情况，我们应该测试输入作如下分区：图是否为空图，当前顶点是否在图中。并对这两种情况做笛卡尔积，排除掉图为空，且当前顶点在图中的情况。</p> <p>结果：分别对三种情况做测试，测试通过。</p> <ul><li>2&gt;	public int set(L source, L target, int weight);</li></ul> <p>设计：此时根据图是否为空，当前的边是否在图中，当前的顶点是否在图中，以及weight是否为0分区。对这些分区求笛卡尔积做测试，由于分区的笛卡尔积存在某些不可能出现的情况，故此时分为以下几种情况：</p> <p>顶点在图中，边不在图中，图不为空，weight=0</p> <p>顶点不在图中，边不在图中，图为空，weight=0</p> <p>顶点在图中，边在图中，图不为空，weight=0</p> <p>顶点在图中，边在图中，图不为空，weight!=0</p> <p>顶点在图中，边不在图中，图不为空，weight!=0</p> <p>顶点不在图中，边不在图中，图为空，weight!=0</p> <p>思路、过程：根据方法上方的注释分析，我们需要添加，改变，或删除一个加权有向边在这个图中，如果weight!=0，则添加一条边，或更新该边的权值。若给定标签的顶点没有出现，则带有给定的标签的顶点将被添加到图中，若weight==0，且存在这条边，则去除这条边，返回之前边的权值。因此我们可以据此，对图是否为空，当前的边是否在图中，当前的顶点是否在图中，以及weight是否为0分区</p> <p>结果：分别对以上几种情况测试，测试通过。</p> <ul><li>3&gt;	public boolean remove(L vertex);</li></ul> <p>设计：此时可以根据当前顶点是否在图中进行分区，则一共分为两种。</p> <p>当前顶点在图中</p> <p>当前顶点不在图中</p> <p>思路、过程：根据方法上方的注释分析，从图中去掉一个顶点，任何和这个顶点相关的边都删除。</p> <p>结果：分别对以上几种情况测试，测试通过。</p> <p>4&gt;	public Set&lt;L&gt; vertices();</p> <p>设计：此时可以根据图是否为空，判断当前是否会返回值，因此分为以下两种情况。</p> <p>图为空</p> <p>图不为空</p> <p>思路、过程：根据方法上方的注释分析，返回这个图中所有的顶点。</p> <p>结果：分别对以上两种情况测试，测试通过。</p> <p>5&gt;	public Map&lt;L, Integer&gt; sources(L target);</p> <p>设计：此时可以根据顶点是否在图中，顶点是否存在源顶点分区。</p> <p>顶点在图中，顶点存在源顶点</p> <p>顶点不在图中，顶点不存在源顶点</p> <p>顶点在图中，定点不存在源顶点</p> <p>顶点不在图中，顶点存在源顶点</p> <p>思路、过程：根据方法上方的注释分析，获取带有指向目标顶点的边的源顶点以及这些边的权值。因此我们可以根据当前顶点是否在图中，以及定点是否存在源顶点分区。</p> <p>结果：分别对以上四种情况测试，测试通过。</p> <p>6&gt;	public Map&lt;L, Integer&gt; targets(L source);</p> <p>设计：此时可以根据顶点是否在图中，顶点是否存在目标顶点分区。</p> <p>顶点在图中，顶点存在目标顶点</p> <p>顶点不在图中，顶点存在目标顶点</p> <p>顶点在图中，顶点不存在目标顶点</p> <p>顶点不在图中，顶点不存在目标顶点</p> <p>思路、过程：根据方法上方的注释分析，我们需要从源顶点获得带有有向边的目标顶点以及这些边的权值。因此我们可以对当前顶点是否在图中、当前顶点是否存在目标顶点分区。</p> <p>结果：分别对以上四种情况测试，测试通过。</p> <p>以下截图为在实现Problem2后对Problem1进行的测试：</p> <p>依次通过ConcreteEdgesGraph与ConcreteVerticesGraph实现：</p> <p><img src="/SoftwareConstruction/experiment2/image004.png" alt="image004.png"></p> <p><img src="/SoftwareConstruction/experiment2/image005.png" alt="image005.png"></p> <h4 id="problem-2-implement-graph-string"><a href="#problem-2-implement-graph-string" class="header-anchor">#</a> Problem 2: Implement Graph &lt;String&gt;</h4> <h5 id="implement-concreteedgesgraph"><a href="#implement-concreteedgesgraph" class="header-anchor">#</a> Implement ConcreteEdgesGraph</h5> <ul><li>1&gt;	Edge类：</li></ul> <p>Edge类的私有变量如下，由于Edge类的变量都是用private、final修饰，且String、Integer均为不可变类型，因此Edge类不可变：</p> <table><thead><tr><th style="text-align:center;">变量</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">private final String source;</td> <td style="text-align:center;">边的起点</td></tr> <tr><td style="text-align:center;">private final String target;</td> <td style="text-align:center;">边的终点</td></tr> <tr><td style="text-align:center;">private final Integer weight;</td> <td style="text-align:center;">边的权值</td></tr></tbody></table> <p><strong>Edge类的方法如下：</strong></p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">public Edge(final String sourceConstruct,final String targetConstruct,final int weightConstruct)</td> <td style="text-align:center;">构造函数</td></tr> <tr><td style="text-align:center;">public void checkRep()</td> <td style="text-align:center;">检查不变量，weight&gt;0, source!=null, target!=null</td></tr> <tr><td style="text-align:center;">public String getWeight ()</td> <td style="text-align:center;">获取边的weight值</td></tr> <tr><td style="text-align:center;">public String getSource ()</td> <td style="text-align:center;">获取边的起点</td></tr> <tr><td style="text-align:center;">public String getTarget()</td> <td style="text-align:center;">获取边的终点</td></tr> <tr><td style="text-align:center;">public String toString()</td> <td style="text-align:center;">返回边的字符串表示</td></tr></tbody></table> <ul><li>// Abstraction function:</li> <li>// 从source到target，且权值为weight的有向边</li> <li>// Representation invariant:</li> <li>// weight&gt;0,且source!=null,target!=null</li> <li>// Safety from rep exposure:</li> <li>// 使用private和final修饰变量，且使用变量的类型均为不可变类型。</li> <li>// 避免从外部直接修改的风险。</li></ul> <p>CheckRep:</p> <p><img src="/SoftwareConstruction/experiment2/image006.png" alt="image006.png"></p> <p>我们此时只需要检查this.weight&gt;0,this.target!=null,this.source!=null，即可完成对不变量的检查。</p> <p>toString:</p> <p><img src="/SoftwareConstruction/experiment2/image007.png" alt="image007.png"></p> <p>将toString函数打印方法设置如上，方便读取。</p> <ul><li>2&gt;	ConcreteEdgesGraph类：</li></ul> <p>ConcreteEdgesGraph有两个私有变量：</p> <table><thead><tr><th style="text-align:center;">变量</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">private final Set&lt;String&gt; vertices = new HashSet&lt;&gt;()</td> <td style="text-align:center;">图的所有顶点</td></tr> <tr><td style="text-align:center;">private final List&lt;Edge&gt; edges = new ArrayList&lt;&gt;()</td> <td style="text-align:center;">图的所有边</td></tr></tbody></table> <p>ConcreteEdgesGraph的方法如下：</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">public ConcreteEdgesGraph()</td> <td style="text-align:center;">构造函数，创建一个空图</td></tr> <tr><td style="text-align:center;">public void checkRep()</td> <td style="text-align:center;">检查不变量</td></tr> <tr><td style="text-align:center;">public boolean add(String vertex)</td> <td style="text-align:center;">向图中添加一个边</td></tr> <tr><td style="text-align:center;">public int set(String source, String target, int weight)</td> <td style="text-align:center;">添加、该边、或删除一个图中的一个加权有向边</td></tr> <tr><td style="text-align:center;">public boolean remove(String vertex)</td> <td style="text-align:center;">去掉图中的一个顶点</td></tr> <tr><td style="text-align:center;">public Set&lt;String&gt; vertices()</td> <td style="text-align:center;">返回图中所有的顶点</td></tr> <tr><td style="text-align:center;">public Map&lt;String, Integer&gt; sources(String target)</td> <td style="text-align:center;">返回target顶点的所有源顶点及权值的映射</td></tr> <tr><td style="text-align:center;">public Map&lt;String, Integer&gt; targets(String source)</td> <td style="text-align:center;">返回source顶点的所有目标定点及权值的映射</td></tr> <tr><td style="text-align:center;">public String toString()</td> <td style="text-align:center;">返回图的字符串表示</td></tr></tbody></table> <p>继承关系如下所示：</p> <p><img src="/SoftwareConstruction/experiment2/image008.png" alt="image008.png"></p> <ul><li>// Abstraction function:</li> <li>// 由顶点为vertices、边为edges组成的图</li> <li>// 即从vertices、edges到有向图的映射</li> <li>// Representation invariant:</li> <li>// edges.getWeight&gt;0,且edges中不存在两条相同的边</li> <li>// vertices中的顶点不为空</li> <li>// Safety from rep exposure:</li> <li>// 使用private和final修饰变量</li> <li>// 使用防御性复制</li></ul> <p>CheckRep:</p> <p><img src="/SoftwareConstruction/experiment2/image009.png" alt="image009.png"></p> <p>检查edges中是否存在相同的边，edges中每条边的权值是否大于，以及是否存在顶点为空的情况。</p> <p>toString:</p> <p><img src="/SoftwareConstruction/experiment2/image010.png" alt="image010.png"></p> <p>将toString函数打印方法设置如上，方便读取。</p> <ul><li>3&gt;	测试策略</li></ul> <p>对ConcreteEdgesGraph类的测试策略如下：</p> <ol><li>public boolean add(String vertex)
<ul><li>// Testing s* trategy for ConcreteEdgesGraph.add()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether the vertex is in the vertices</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public int set(String source, String target, int weight)
<ul><li>// Testing strategy for ConcreteEdgesGraph.set()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether the edge is in the graph</li> <li>// weight : &gt;0 =0</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public boolean remove(String vertex)
<ul><li>// Testing strategy for ConcreteEdgesGraph.remove()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether the vertex is in the graph</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Set&lt;String&gt; vertices()
<ul><li>// Testing strategy for ConcreteEdgesGraph.vertices()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether the graph is empty</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Map&lt;String, Integer&gt; sources(String target)
<ul><li>// Testing strategy for ConcreteEdgesGraph.sources()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether the target has sources</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Map&lt;String, Integer&gt; targets(String source)
<ul><li>// Testing strategy for ConcreteEdgesGraph.targets()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether the source has targets</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String toString()
<ul><li>// Testing strategy for ConcreteEdgesGraph.toString()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether the graph is empty</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li></ol> <p>对Edge类的测试策略如下：</p> <ol><li>public String getWeight ()
<ul><li>// Testing strategy for Edge.getWeight()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Whether the weght is null</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String getSource ()
<ul><li>// Testing strategy for Edge.getSource()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Whether the source is null</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String getTarget()
<ul><li>// Testing strategy for Edge.getTarget()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Whether the target is null</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String toString()
<ul><li>// Testing strategy for Edge.toString()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Whether the Edge is empty</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li></ol> <ul><li>4&gt;	测试结果：</li></ul> <p>可以看到所有测试通过，并且，代码覆盖率为100%.</p> <p><img src="/SoftwareConstruction/experiment2/image011.png" alt="image011.png"></p> <p><img src="/SoftwareConstruction/experiment2/image012.png" alt="image012.png"></p> <p><img src="/SoftwareConstruction/experiment2/image013.png" alt="image013.png"></p> <h5 id="implement-concreteverticesgraph"><a href="#implement-concreteverticesgraph" class="header-anchor">#</a> Implement ConcreteVerticesGraph</h5> <ul><li>1&gt;	Vertex类：</li></ul> <p>Vertex中含有两个私有变量：</p> <p><img src="/SoftwareConstruction/experiment2/image014.png" alt="image014.png"></p> <p>以下为Vertex中的方法：</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">public Vertex(final String VertexName);</td> <td style="text-align:center;">构造函数</td></tr> <tr><td style="text-align:center;">public void checkRep();</td> <td style="text-align:center;">检查不变量</td></tr> <tr><td style="text-align:center;">public boolean isEqualsVertex(Vertex vertexAnother);</td> <td style="text-align:center;">检查顶点的名字是否与当前顶点名字相同</td></tr> <tr><td style="text-align:center;">public boolean isEqualsName(String vertexAnother);</td> <td style="text-align:center;">检查字符串是否与当前顶点名字相同</td></tr> <tr><td style="text-align:center;">public void writeTarget(String vertexAnother, Integer weight);</td> <td style="text-align:center;">将有向边写入TargetEdge中</td></tr> <tr><td style="text-align:center;">public String Name();</td> <td style="text-align:center;">返回当前顶点的名字</td></tr> <tr><td style="text-align:center;">public Map&lt;String, Integer&gt; Target();</td> <td style="text-align:center;">返回当前顶点所有目标顶点及对应权值</td></tr> <tr><td style="text-align:center;">public Integer weight(String vertexAnother);</td> <td style="text-align:center;">返回当前顶点所有源顶点及对应权值</td></tr> <tr><td style="text-align:center;">public boolean remove(String vertexTarget);</td> <td style="text-align:center;">去除掉当前顶点的vertexTarget目标顶点</td></tr> <tr><td style="text-align:center;">public String toString();</td> <td style="text-align:center;">返回图的字符串表示</td></tr></tbody></table> <ul><li>// Abstraction function:</li> <li>// 由顶点的名字及其对应目标顶点的映射所对应的实际顶点表示</li> <li>// 即由String、Map组成的抽象数据类型对应的顶点</li> <li>// Representation invariant:</li> <li>// vertex不为空且TargetEdge中的weight&gt;0</li> <li>// Safety from rep exposure:</li> <li>// 使用private、final修饰的变量</li> <li>// 防御性复制</li></ul> <p>CheckRep:</p> <p><img src="/SoftwareConstruction/experiment2/image015.png" alt="image015.png"></p> <p>检查vertex不为空且TargetEdge中的weight&gt;0。</p> <p>toString:</p> <p>将toString函数打印方法设置如上，方便读取。</p> <p><img src="/SoftwareConstruction/experiment2/image016.png" alt="image016.png"></p> <p>2&gt;	ConcreteVerticesGraph类：</p> <p>ConcreteVerticesGraph类有一个私有变量：</p> <table><thead><tr><th style="text-align:center;">变量</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">private final List&lt;Vertex&gt; vertices = new ArrayList&lt;&gt;()</td> <td style="text-align:center;">存储所有顶点</td></tr></tbody></table> <p>以下为ConcreteVerticesGraph的方法：</p> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">public ConcreteVerticesGraph()</td> <td style="text-align:center;">构造函数，创建新的空的图</td></tr> <tr><td style="text-align:center;">public void checkRep()</td> <td style="text-align:center;">检查不变量</td></tr> <tr><td style="text-align:center;">public boolean add(String vertex)</td> <td style="text-align:center;">将顶点添加到图中</td></tr> <tr><td style="text-align:center;">public int set(String source, String</td> <td style="text-align:center;">target, int weight)</td></tr> <tr><td style="text-align:center;">public boolean remove(String vertex)</td> <td style="text-align:center;">从图中去掉vertex顶点</td></tr> <tr><td style="text-align:center;">public Set&lt;String&gt; vertices()</td> <td style="text-align:center;">返回图中所有顶点的集合</td></tr> <tr><td style="text-align:center;">public Map&lt;String, Integer&gt; sources(String target)</td> <td style="text-align:center;">返回target在图中的所有源顶点</td></tr> <tr><td style="text-align:center;">public Map&lt;String, Integer&gt; targets(String source)</td> <td style="text-align:center;">返回source在图中的所有目标顶点</td></tr> <tr><td style="text-align:center;">public String toString()</td> <td style="text-align:center;">返回图的字符串表示</td></tr></tbody></table> <p>继承关系如下：</p> <p><img src="/SoftwareConstruction/experiment2/image017.png" alt="image017.png"></p> <ul><li>// Abstraction function:</li> <li>// 由vertices组成的顶点</li> <li>// 即由List&lt;Vertex&gt;类型数据到加权有向图的映射</li> <li>// Representation invariant:</li> <li>// vertices中不存在重复的顶点</li> <li>// Safety from rep exposure:</li> <li>// 使用private、final修饰变量</li> <li>// 采用防御性复制</li></ul> <p>CheckRep:</p> <p><img src="/SoftwareConstruction/experiment2/image018.png" alt="image018.png"></p> <p>toString:</p> <p>将toString函数打印方法设置如上，方便读取.</p> <p><img src="/SoftwareConstruction/experiment2/image019.png" alt="image019.png"></p> <ul><li>3&gt;	测试策略:</li></ul> <p>对ConcreteVerticesGraph的测试策略：</p> <ol><li>public boolean add(String vertex)
<ul><li>// Testing strategy for ConcreteVerticesGraph.add()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// 是否为空图： empty graph？ yes 、no</li> <li>// 当前的顶点是否在图中：whether vertex is in the graph？ yes 、no</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public int set(String source, String target, int weight)
<ul><li>// Testing strategy for ConcreteVerticesGraph.set()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// 当前的顶点是否在图中：whether vertex is in the graph？ yes 、no</li> <li>// value of weight？ =0、&gt;0</li> <li>// 顶点是否存在目标顶点：whether vertex has target? yes 、no</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public boolean remove(String vertex)
<ul><li>// Testing strategy for ConcreteVerticesGraph.remove()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// 是否为空图： empty graph？ yes 、no</li> <li>// 当前的顶点是否在图中：whether vertex is in the graph？ yes 、no</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Set&lt;String&gt; vertices()
<ul><li>// Testing strategy for ConcreteVerticesGraph.vertices()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// 是否为空图： empty graph？ yes 、no</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Map&lt;String, Integer&gt; sources(String target)
<ul><li>// Testing strategy for ConcreteVerticesGraph.sources()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// 是否为空图： empty graph？ yes 、no</li> <li>// 当前的顶点是否在图中：whether vertex is in the graph？ yes 、no</li> <li>// 顶点是否存在源顶点：whether vertex has source? yes 、no</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Map&lt;String, Integer&gt; targets(String source)
<ul><li>// Testing strategy for ConcreteVerticesGraph.targets()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// 是否为空图： empty graph？ yes 、no</li> <li>// 当前的顶点是否在图中：whether vertex is in the graph？ yes 、no</li> <li>// 顶点是否存在目标顶点：whether vertex has target? yes 、no</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String toString()
<ul><li>// Testing strategy for ConcreteVerticesGraph.toString()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// empty graph: yes 、no</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li></ol> <p>对Vertex类的测试策略如下：</p> <ol><li>public boolean isEqualsVertex(Vertex vertexAnother)
<ul><li>// Testing strategy for Vertex.isEqualsVertex()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether vertexAnother is equal to Vertex</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public boolean isEqualsName(String vertexAnother)
<ul><li>// Testing strategy for Vertex.isEqualsName()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether vertexAnother's name is equal to Vertex</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public void writeTarget(String vertexAnother, Integer weight)
<ul><li>// Testing strategy for Vertex.writeTarget()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether vertexAnother is in the TargetEdge</li> <li>// weight:&gt;0 =0</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String Name()
<ul><li>// Testing strategy for Vertex.Name()</li> <li>//</li> <li>// whether Vertex is null</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Map&lt;String, Integer&gt; Target()
<ul><li>// Testing strategy for Vertex.Target()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// wherger TargetEdge is null</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public Integer weight(String vertexAnother)
<ul><li>// Testing strategy for Vertex.weight()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether vertexAnother is in the TargetEdge</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public boolean remove(String vertexTarget)
<ul><li>// Testing strategy for Vertex.remove()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// vertexTarget is in the TargetEdge or not</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String toString()
<ul><li>// Testing strategy for Vertex.toString()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// vertex is null or not</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li></ol> <ul><li>4&gt;	测试结果</li></ul> <p>可以看到测试全部通过，且代码覆盖率为100%:</p> <p><img src="/SoftwareConstruction/experiment2/image020.png" alt="image020.png"></p> <p><img src="/SoftwareConstruction/experiment2/image021.png" alt="image021.png"></p> <p><img src="/SoftwareConstruction/experiment2/image022.png" alt="image022.png"></p> <h4 id="problem-3-implement-generic-graph-l"><a href="#problem-3-implement-generic-graph-l" class="header-anchor">#</a> Problem 3: Implement generic Graph&lt;L&gt;</h4> <h5 id="make-the-implementations-generic"><a href="#make-the-implementations-generic" class="header-anchor">#</a> Make the implementations generic</h5> <p>此时具体类的声明如下：</p> <p><img src="/SoftwareConstruction/experiment2/image023.png" alt="image023.png"></p> <p><img src="/SoftwareConstruction/experiment2/image024.png" alt="image024.png"></p> <p><img src="/SoftwareConstruction/experiment2/image025.png" alt="image025.png"></p> <p><img src="/SoftwareConstruction/experiment2/image026.png" alt="image026.png"></p> <p>并对problem2部分实现的功能修改，使其支持泛型。</p> <p>将ConcreteEdgesGraph及ConcreteVerticesGraph中部分用String声明的变量修改为L，并且在声明类的时候，使用泛型L。</p> <p>实现后具体类的修改后，对其测试，发现测试全部通过。且覆盖率仍为100%</p> <p><img src="/SoftwareConstruction/experiment2/image027.png" alt="image027.png"></p> <p><img src="/SoftwareConstruction/experiment2/image028.png" alt="image028.png"></p> <p><img src="/SoftwareConstruction/experiment2/image029.png" alt="image029.png"></p> <h5 id="implement-graph-empty"><a href="#implement-graph-empty" class="header-anchor">#</a> Implement Graph.empty()</h5> <p><img src="/SoftwareConstruction/experiment2/image030.png" alt="image030.png"></p> <p>此处选择ConcreteEdgesGraph或ConcreteVerticesGraph中的一个。</p> <p>为了确保支持不同的类型，分别测试两种不同的类型Integer、Charater。</p> <p>分别对不同的类型对实现的方法测试：</p> <p><img src="/SoftwareConstruction/experiment2/image031.png" alt="image031.png"></p> <p><img src="/SoftwareConstruction/experiment2/image032.png" alt="image032.png"></p> <p><img src="/SoftwareConstruction/experiment2/image033.png" alt="image033.png"></p> <p><img src="/SoftwareConstruction/experiment2/image034.png" alt="image034.png"></p> <p>如图，此时测试覆盖率为100%.</p> <h4 id="problem-4-poetic-walks"><a href="#problem-4-poetic-walks" class="header-anchor">#</a> Problem 4: Poetic walks</h4> <h5 id="test-graphpoet"><a href="#test-graphpoet" class="header-anchor">#</a> Test GraphPoet</h5> <p>对GraphPoet类的测试如下：</p> <ol><li>public GraphPoet(File corpus)
<ul><li>// Testing strategy for the constructor of GraphPoet</li> <li>// Testing strategy for GraphPoet.toString()</li> <li>// Partition the inputs as follows:</li> <li>// whether the corpus is not exist</li> <li>// whether the corpus is a empty file</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String poem(String input)
<ul><li>// Testing strategy for GraphPoet.poem()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Whether the input has the same edge</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul></li> <li>public String toString()
<ul><li>// Testing strategy for the constructor of GraphPoet</li> <li>// Testing strategy for GraphPoet.toString()</li> <li>// Partition the inputs as follows:</li> <li>// whether the corpus is not exist</li> <li>// whether the corpus is a empty file</li></ul></li></ol> <p>在完成下一单元后，对其测试，测试结果：</p> <p><img src="/SoftwareConstruction/experiment2/image035.png" alt="image035.png"></p> <p>可以看到，此时覆盖率为百分值百：</p> <p><img src="/SoftwareConstruction/experiment2/image036.png" alt="image036.png"></p> <p>对部分测试策略分析：
当输入文件为下方文件时：
&gt; To explore to explore interesting new interesting explore interesting explore strange new worlds
&gt; To seek out new life and new civilizations and civilizations and</p> <p>此时graph如图所示：</p> <p><img src="/SoftwareConstruction/experiment2/image037.png" alt="image037.png"></p> <p>当我们的输入语句为Seek to explore new and exciting synergies!时，此时对应的语句应该为Seek to explore interesting new civilizations and exciting synergies!
当此时输入文件为下方字符时：</p> <p>&gt; To explore strange new worlds
&gt; To seek out new life and new civilizations</p> <p>此时graph如图所示：</p> <p><img src="/SoftwareConstruction/experiment2/image038.png" alt="image038.png"></p> <p>当我们的输入语句为Seek to explore new and exciting synergies!时，此时对应的语句应该为Seek to explore strange new life and exciting synergies!</p> <h5 id="implement-graphpoet"><a href="#implement-graphpoet" class="header-anchor">#</a> Implement GraphPoet</h5> <ul><li><ol><li>public GraphPoet(File corpus)</li></ol></li></ul> <p>首先是文件的读取，采用System.getProperty(&quot;user.dir&quot;)的函数读取当前工作区，并加上路径，读取出所需的文件。</p> <p>再通过BufferedReader、FileReader将文件读取到一个字符串中，再通过split函数，将所有空格消除，并读取到List中，再通过List中的removeAll函数，将所有的空字符串删除，此时即可得到文件中所有的单词，并保存到一个列表中。</p> <p>依次对所有的单词遍历，若前一个节点及后一个节点都在图中，且weight++，否则令weight=1.</p> <ul><li><ol start="2"><li>public String poem(String input)</li></ol></li></ul> <p>首先将input的输入通过split函数，切分为每个单词，并通过与GraphPoet相似的方法，获得单词的列表，此时我们用List中的顺序，每次取出第i个，及第i+1，如果第i个单词及第i+1个单词之间在图中存在别的单词连接，则将这个单词放到StringBuilder中。直到结束后，将最后一个单词也放进，并加上感叹号。</p> <p>具体结构如下：</p> <p><img src="/SoftwareConstruction/experiment2/image039.png" alt="image039.png"></p> <h5 id="graph-poetry-slam"><a href="#graph-poetry-slam" class="header-anchor">#</a> Graph poetry slam</h5> <p><img src="/SoftwareConstruction/experiment2/image040.png" alt="image040.png"></p> <p>对于如图所示的main函数，由于输入的文件为：
&gt; This is a test of the Mugar Omni Theater sound system.</p> <p>因此在test与the中间存在of单词，因此输出结果应该为：Test of the system!</p> <p>通过测试，所得结果与预期一致，完成预期要求。</p> <p><img src="/SoftwareConstruction/experiment2/image041.png" alt="image041.png"></p> <h4 id="使用eclemma检查测试的代码覆盖度"><a href="#使用eclemma检查测试的代码覆盖度" class="header-anchor">#</a> 使用Eclemma检查测试的代码覆盖度</h4> <p>由于IDE采用IntelliJ IDEA 2020.3.1，此处使用IDEA内置的使用覆盖率测试：</p> <p><img src="/SoftwareConstruction/experiment2/image042.png" alt="image042.png"></p> <p><img src="/SoftwareConstruction/experiment2/image043.png" alt="image043.png"></p> <p>可以看到此时覆盖率为100%。</p> <p><img src="/SoftwareConstruction/experiment2/image044.png" alt="image044.png"></p> <p>将工作区复制到Ecilipse中，用Eclemma检测覆盖率，此时覆盖率仍然大约为95%左右。</p> <p><img src="/SoftwareConstruction/experiment2/image045.png" alt="image045.png"></p> <h4 id="before-you-re-done"><a href="#before-you-re-done" class="header-anchor">#</a> Before you’re done</h4> <p>通过Git提交当前版本到GitHub上你的Lab2仓库。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit -m <span class="token string">&quot;P1&quot;</span>
<span class="token function">git</span> push
</code></pre></div><p>项目的目录结构树状示意图如下方所示：
此处采用linux中的tree命令.</p> <h3 id="re-implement-the-social-network-in-lab1"><a href="#re-implement-the-social-network-in-lab1" class="header-anchor">#</a> Re-implement the Social Network in Lab1</h3> <h4 id="friendshipgraph类"><a href="#friendshipgraph类" class="header-anchor">#</a> FriendshipGraph类</h4> <ul><li>1.FriendshipGraph类有一个私有变量：
private Graph&lt;Person&gt; graph = Graph.empty();</li> <li>2.FriendshipGraph类的方法如下：</li></ul> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">public void checkRep()</td> <td style="text-align:center;">检查不变量</td></tr> <tr><td style="text-align:center;">public boolean addVertex(Person person)</td> <td style="text-align:center;">添加顶点</td></tr> <tr><td style="text-align:center;">public boolean addEdge(Person person1,Person person2)</td> <td style="text-align:center;">添加边</td></tr> <tr><td style="text-align:center;">public int getDistance(Person person1,Person person2)</td> <td style="text-align:center;">返回从person1到person2的距离</td></tr></tbody></table> <p>关系图如下：</p> <p><img src="/SoftwareConstruction/experiment2/image046.png" alt="image046.png"></p> <ul><li>// Abstraction function:</li> <li>// 由Graph&lt;Person&gt; graph对应的图</li> <li>// Representation invariant:</li> <li>// graph中所有边的weight=0或=1，且顶点名字不为空</li> <li>// Safety from rep exposure:</li> <li>// 使用private、final修饰的变量</li> <li>// 防御性复制</li></ul> <p>checkRep如下：</p> <p><img src="/SoftwareConstruction/experiment2/image047.png" alt="image047.png"></p> <p>getDistance的实现如下：</p> <ul><li>1.将person1保存到HashSet&lt;Person&gt; Search中；</li> <li>2.将person1认识的人保存到HashSet&lt;Person&gt; Search_Next中；</li> <li>3.将Search和Search_Next都保存到新的HashSet&lt;Person&gt; Search_assist中；</li> <li>4.初始化distance = 1；</li> <li>5.若Search_Next中含有person2，返回distance，即为所求距离。否则将Search清空，将Search_Next保存到Search中，在将Search中所有的人认识的人的HashSet中所有的元素添加到Search_Next，再将Search_Next中所有在Search_assist中保存的元素消除掉，再将所有Search_Next元素添加到Search_assist中。此时distance++；</li> <li>6.重复步骤5，若Search_Next最终为空，则不存在距离，返回值为-1；否则，person1与person2之间存在路径，且 person1与person2距离为distance。</li></ul> <h4 id="person类"><a href="#person类" class="header-anchor">#</a> Person类</h4> <ul><li><ol><li>Person类有一个私有变量：</li></ol></li></ul> <p>private final String name;</p> <ul><li><ol start="2"><li>FriendshipGraph类的方法如下：</li></ol></li></ul> <table><thead><tr><th style="text-align:center;">方法</th> <th style="text-align:center;">意义</th></tr></thead> <tbody><tr><td style="text-align:center;">public Person(String personName)</td> <td style="text-align:center;">构造函数</td></tr> <tr><td style="text-align:center;">public void checkRep()</td> <td style="text-align:center;">检查不变量</td></tr> <tr><td style="text-align:center;">public String getName()</td> <td style="text-align:center;">返回当前Person的姓名</td></tr></tbody></table> <ul><li>// Abstraction function:</li> <li>// 由String name对应的Person</li> <li>// Representation invariant:</li> <li>// name不为空</li> <li>// Safety from rep exposure:</li> <li>// 使用private、final修饰的变量</li> <li>// 防御性复制</li></ul> <p>checkRep如下：</p> <p><img src="/SoftwareConstruction/experiment2/image048.png" alt="image048.png"></p> <h4 id="客户端main"><a href="#客户端main" class="header-anchor">#</a> 客户端main()</h4> <p>此处将重新利用Lab1中main客户端，由于对addVertex、addEdge、getDistance该函数均已完成，因此此处重新利用即可。
运行发现，与预期结果一致。</p> <p><img src="/SoftwareConstruction/experiment2/image049.png" alt="image049.png"></p> <h4 id="测试用例"><a href="#测试用例" class="header-anchor">#</a> 测试用例</h4> <p>对于FriendshipGraph类：</p> <ol><li>测试策略：</li></ol> <p>1.1	public boolean addVertex(Person person)</p> <ul><li>// Testing strategy for GraphPoet.addVertex()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Whether the grapg is empty</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul> <p>1.2	public boolean addEdge(Person person1,Person person2)</p> <ul><li>// Testing strategy for GraphPoet.addVertex()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Whether the edge is in the graph</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.
1.3	public int getDistance(Person person1,Person person2)</li> <li>// Testing strategy for GraphPoet.getDistance()</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// Is it possible to go from A to B</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul> <ol start="2"><li><p>测试结果</p> <p>此处主要说明对getDistance的测试，其余部分详见代码。
通过以下的图，对getDistance测试：
由图可得，ben 与 a 的距离为 2，ben 与 kramer 的距离为 3，b 与 kramer的距离为 2，kramer 与 rachel 的距离为 5。
并进行测试：</p></li></ol> <p><img src="/SoftwareConstruction/experiment2/image050.png" alt="image050.png"></p> <p><img src="/SoftwareConstruction/experiment2/image051.png" alt="image051.png"></p> <p><img src="/SoftwareConstruction/experiment2/image052.png" alt="image052.png"></p> <p><img src="/SoftwareConstruction/experiment2/image053.png" alt="image053.png"></p> <p>可以发现，此时测试全部通过测试，并且代码覆盖率为100%.</p> <p>对于Person类：</p> <ol><li>测试策略</li></ol> <ul><li>// Testing strategy for Person.getName</li> <li>//</li> <li>// Partition the inputs as follows:</li> <li>// whether Person is null</li> <li>//</li> <li>// Exhaustive Cartesian coverage of partitions.</li></ul> <ol start="2"><li>测试结果</li></ol> <p>测试全部通过，并且代码覆盖率100%。</p> <p><img src="/SoftwareConstruction/experiment2/image054.png" alt="image054.png"></p> <p><img src="/SoftwareConstruction/experiment2/image055.png" alt="image055.png"></p> <h4 id="提交至git仓库"><a href="#提交至git仓库" class="header-anchor">#</a> 提交至Git仓库</h4> <p>如何通过Git提交当前版本到GitHub上你的Lab2仓库。
在这里给出你的项目的目录结构树状示意图。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit -m <span class="token string">&quot;P2&quot;</span>
<span class="token function">git</span> push
</code></pre></div><p>目录结构树状示意图如下所示：</p> <p>此处采用linux中的tree命令.</p> <h2 id="实验过程中遇到的困难与解决途径"><a href="#实验过程中遇到的困难与解决途径" class="header-anchor">#</a> 实验过程中遇到的困难与解决途径</h2> <table><thead><tr><th style="text-align:center;">遇到的难点</th> <th style="text-align:center;">解决途径</th></tr></thead> <tbody><tr><td style="text-align:center;">泛型的转换最初理解起来稍有问难。</td> <td style="text-align:center;">通过查阅资料并与同学讨论等途径解决。</td></tr> <tr><td style="text-align:center;">对于题目某些部分理解起来稍有困难。</td> <td style="text-align:center;">通过自己耐心探究解决。</td></tr> <tr><td style="text-align:center;">测试策略的设计。</td> <td style="text-align:center;">通过查阅相关资料并加以体会解决。</td></tr></tbody></table> <h2 id="实验过程中收获的经验、教训、感想"><a href="#实验过程中收获的经验、教训、感想" class="header-anchor">#</a> 实验过程中收获的经验、教训、感想</h2> <ul><li>1.掌握了在测试中，写出测试策略，并根据此设计测试用例的方法</li> <li>2.了解了OOP实现ADT，并对RI、REP、AF等有了更深的了解</li> <li>3.对于整个过程了解更加深刻</li> <li>4.掌握了ADT设计的基本方法</li> <li>5.了解了ADT的泛型化</li> <li>6.意识到避免表示泄露的重要性，并在实践中，践行了保护的过程</li></ul> <h2 id="针对以下方面的感受"><a href="#针对以下方面的感受" class="header-anchor">#</a> 针对以下方面的感受</h2> <p>(1)	面向ADT的编程和直接面向应用场景编程，你体会到二者有何差异？</p> <p>在面向ADT的编程设计，我们往往要考虑程序的功能、应用场景以及复用性，使编出的程序更加灵活；而面向应用场景编程，适用范围较小，但可以根据具体场景，灵活编程。</p> <p>(2)	使用泛型和不使用泛型的编程，对你来说有何差异？</p> <p>使用泛型可以更改数据类型，如P2可以以Person为数据类型，在初次接触时有一些不适应，但很快便了解并掌握。泛型为程序的复用性带来了很大帮助，并且使类型更加安全。</p> <p>(3)	在给出ADT的规约后就开始编写测试用例，优势是什么？你是否能够适应这种测试方式？</p> <p>先完成测试用例的编写能够让我更好的理解规格说明。规格说明也可能存在问题--不正确、不完整、模棱两可、确实边界情况。 因此先尝试编写测试用例，可以在我浪费时间实现一个有问题的规格说明之前发现这些问题。因此我能够适应这种测试方式。</p> <p>(4)	P1设计的ADT在多个应用场景下使用，这种复用带来什么好处？</p> <p>避免重复实现具有类似功能的ADT，将已有代码进行复用，不仅在一定程度上节约了时间，同时还能进一步保证程序的正确性，避免写类似代码时，犯更多的错误。同时还能够锻炼我们的抽象能力，在实现ADT时候，充分考虑应用场景。</p> <p>(5)	P3要求你从0开始设计ADT并使用它们完成一个具体应用，你是否已适应从具体应用场景到ADT的“抽象映射”？相比起P1给出了ADT非常明确的rep和方法、ADT之间的逻辑关系，P3要求你自主设计这些内容，你的感受如何？</p> <p>实验未要求P3.</p> <p>(6)	为ADT撰写specification, invariants, RI, AF，时刻注意ADT是否有rep exposure，这些工作的意义是什么？你是否愿意在以后编程中坚持这么做？</p> <p>表示暴露影响程序的安全运行，同时影响到不变性和表示独立性处理表示暴露避免类内部数据被从外部访问。并且在编程时候在抽象类型表示声明后写上对于抽象函数和表示不变量的注解，可以便于读取表示不变量、抽象域的表示、规定合法的表示值如何被解释到抽象域。方便程序员的处理。以后也会坚持这个习惯。</p> <p>(7)	关于本实验的工作量、难度、deadline。</p> <p>本实验工作量较大，尤其是编写测试时，耗费时间较长，难度可以接受，deadline比较合理。</p> <p>(8)	《软件构造》课程进展到目前，你对该课程有何体会和建议？</p> <p>使我对软件构造有了新的感悟，一方面对程序的测试分区等有了新的体会，另一方面，对规范的注释等有了新的了解，另一方面更加体会到了面向对象编程，除此之外，更加了解了如何保证程序的安全运行。
建议，对PPT内容扩充，方便同学们复习。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新日期:</span> <span class="time">6/6/2021, 1:50:03 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/sidebar_experiment1.html" class="prev">
        实验一
      </a></span> <span class="next"><a href="/sidebar_experiment3.html">
        实验三
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0c046186.js" defer></script><script src="/assets/js/2.81c555ed.js" defer></script><script src="/assets/js/16.78ed62cb.js" defer></script>
  </body>
</html>
